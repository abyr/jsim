// Generated by CoffeeScript 1.6.2
(function() {
  describe("jasmine.Fixtures", function() {
    var ajaxData, anotherFixtureUrl, appendFixturesContainerToDom, fixtureUrl, fixturesContainer;

    ajaxData = "some ajax data";
    fixtureUrl = "some_url";
    anotherFixtureUrl = "another_url";
    fixturesContainer = function() {
      return $("#" + jasmine.getFixtures().containerId);
    };
    appendFixturesContainerToDom = function() {
      return $("body").append("<div id=\"" + jasmine.getFixtures().containerId + "\">old content</div>");
    };
    beforeEach(function() {
      jasmine.getFixtures().clearCache();
      return spyOn(jasmine.Fixtures.prototype, "loadFixtureIntoCache_").andCallFake(function(relativeUrl) {
        return this.fixturesCache_[relativeUrl] = ajaxData;
      });
    });
    describe("default initial config values", function() {
      it("should set 'jasmine-fixtures' as the default container id", function() {
        return expect(jasmine.getFixtures().containerId).toEqual("jasmine-fixtures");
      });
      return it("should set 'spec/javascripts/fixtures' as the default fixtures path", function() {
        return expect(jasmine.getFixtures().fixturesPath).toEqual("spec/javascripts/fixtures");
      });
    });
    describe("cache", function() {
      describe("clearCache", function() {
        return it("should clear cache and in effect force subsequent AJAX call", function() {
          jasmine.getFixtures().read(fixtureUrl);
          jasmine.getFixtures().clearCache();
          jasmine.getFixtures().read(fixtureUrl);
          return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(2);
        });
      });
      it("first-time read should go through AJAX", function() {
        jasmine.getFixtures().read(fixtureUrl);
        return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(1);
      });
      return it("subsequent read from the same URL should go from cache", function() {
        jasmine.getFixtures().read(fixtureUrl, fixtureUrl);
        return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(1);
      });
    });
    describe("read", function() {
      it("should return fixture HTML", function() {
        var html;

        html = jasmine.getFixtures().read(fixtureUrl);
        return expect(html).toEqual(ajaxData);
      });
      it("should return duplicated HTML of a fixture when its url is provided twice in a single call", function() {
        var html;

        html = jasmine.getFixtures().read(fixtureUrl, fixtureUrl);
        return expect(html).toEqual(ajaxData + ajaxData);
      });
      it("should return merged HTML of two fixtures when two different urls are provided in a single call", function() {
        var html;

        html = jasmine.getFixtures().read(fixtureUrl, anotherFixtureUrl);
        return expect(html).toEqual(ajaxData + ajaxData);
      });
      it("should have shortcut global method readFixtures", function() {
        var html;

        html = readFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(html).toEqual(ajaxData + ajaxData);
      });
      it("should use the configured fixtures path concatenating it to the requested url (without concatenating a slash if it already has an ending one)", function() {
        jasmine.getFixtures().fixturesPath = "a path ending with slash/";
        return expect(jasmine.getFixtures().makeFixtureUrl_(fixtureUrl)).toEqual("a path ending with slash/" + fixtureUrl);
      });
      return it("should use the configured fixtures path concatenating it to the requested url (concatenating a slash if it doesn't have an ending one)", function() {
        jasmine.getFixtures().fixturesPath = "a path without an ending slash";
        return expect(jasmine.getFixtures().makeFixtureUrl_(fixtureUrl)).toEqual("a path without an ending slash/" + fixtureUrl);
      });
    });
    describe("load", function() {
      it("should insert fixture HTML into container", function() {
        jasmine.getFixtures().load(fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData);
      });
      it("should insert duplicated fixture HTML into container when the same url is provided twice in a single call", function() {
        jasmine.getFixtures().load(fixtureUrl, fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should insert merged HTML of two fixtures into container when two different urls are provided in a single call", function() {
        jasmine.getFixtures().load(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should have shortcut global method loadFixtures", function() {
        loadFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      describe("when fixture container does not exist", function() {
        return it("should automatically create fixtures container and append it to DOM", function() {
          jasmine.getFixtures().load(fixtureUrl);
          return expect(fixturesContainer().size()).toEqual(1);
        });
      });
      describe("when fixture container exists", function() {
        beforeEach(function() {
          return appendFixturesContainerToDom();
        });
        return it("should replace it with new content", function() {
          jasmine.getFixtures().load(fixtureUrl);
          return expect(fixturesContainer().html()).toEqual(ajaxData);
        });
      });
      return describe("when fixture contains an inline <script> tag", function() {
        beforeEach(function() {
          return ajaxData = "<div><a id=\"anchor_01\"></a><script>$(function(){ $('#anchor_01').addClass('foo')});</script></div>";
        });
        return it("should execute the inline javascript after the fixture has been inserted into the body", function() {
          jasmine.getFixtures().load(fixtureUrl);
          return expect($("#anchor_01")).toHaveClass("foo");
        });
      });
    });
    describe("appendLoad", function() {
      beforeEach(function() {
        return ajaxData = "some ajax data";
      });
      it("should insert fixture HTML into container", function() {
        jasmine.getFixtures().appendLoad(fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData);
      });
      it("should insert duplicated fixture HTML into container when the same url is provided twice in a single call", function() {
        jasmine.getFixtures().appendLoad(fixtureUrl, fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should insert merged HTML of two fixtures into container when two different urls are provided in a single call", function() {
        jasmine.getFixtures().appendLoad(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should have shortcut global method loadFixtures", function() {
        appendLoadFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should automatically create fixtures container and append it to DOM", function() {
        jasmine.getFixtures().appendLoad(fixtureUrl);
        return expect(fixturesContainer().size()).toEqual(1);
      });
      describe("with a prexisting fixture", function() {
        beforeEach(function() {
          return jasmine.getFixtures().appendLoad(fixtureUrl);
        });
        it("should add new content", function() {
          jasmine.getFixtures().appendLoad(fixtureUrl);
          return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
        });
        return it("should not add a new fixture container", function() {
          jasmine.getFixtures().appendLoad(fixtureUrl);
          return expect(fixturesContainer().size()).toEqual(1);
        });
      });
      return describe("when fixture contains an inline <script> tag", function() {
        beforeEach(function() {
          return ajaxData = "<div><a id=\"anchor_01\"></a><script>$(function(){ $('#anchor_01').addClass('foo')});</script></div>";
        });
        return it("should execute the inline javascript after the fixture has been inserted into the body", function() {
          jasmine.getFixtures().appendLoad(fixtureUrl);
          return expect($("#anchor_01")).toHaveClass("foo");
        });
      });
    });
    describe("preload", function() {
      describe("read after preload", function() {
        it("should go from cache", function() {
          jasmine.getFixtures().preload(fixtureUrl, anotherFixtureUrl);
          jasmine.getFixtures().read(fixtureUrl, anotherFixtureUrl);
          return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(2);
        });
        return it("should return correct HTMLs", function() {
          var html;

          jasmine.getFixtures().preload(fixtureUrl, anotherFixtureUrl);
          html = jasmine.getFixtures().read(fixtureUrl, anotherFixtureUrl);
          return expect(html).toEqual(ajaxData + ajaxData);
        });
      });
      it("should not preload the same fixture twice", function() {
        jasmine.getFixtures().preload(fixtureUrl, fixtureUrl);
        return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(1);
      });
      return it("should have shortcut global method preloadFixtures", function() {
        preloadFixtures(fixtureUrl, anotherFixtureUrl);
        jasmine.getFixtures().read(fixtureUrl, anotherFixtureUrl);
        return expect(jasmine.Fixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(2);
      });
    });
    describe("set", function() {
      var html;

      html = "<div>some HTML</div>";
      it("should insert HTML into container", function() {
        jasmine.getFixtures().set(html);
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      it("should insert jQuery element into container", function() {
        jasmine.getFixtures().set($(html));
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      it("should have shortcut global method setFixtures", function() {
        setFixtures(html);
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      describe("when fixture container does not exist", function() {
        return it("should automatically create fixtures container and append it to DOM", function() {
          jasmine.getFixtures().set(html);
          return expect(fixturesContainer().size()).toEqual(1);
        });
      });
      return describe("when fixture container exists", function() {
        beforeEach(function() {
          return appendFixturesContainerToDom();
        });
        return it("should replace it with new content", function() {
          jasmine.getFixtures().set(html);
          return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
        });
      });
    });
    describe("appendSet", function() {
      var html;

      html = "<div>some HTML</div>";
      it("should insert HTML into container", function() {
        jasmine.getFixtures().appendSet(html);
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      it("should insert jQuery element into container", function() {
        jasmine.getFixtures().appendSet($(html));
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      it("should have shortcut global method setFixtures", function() {
        appendSetFixtures(html);
        return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html));
      });
      describe("when fixture container does not exist", function() {
        return it("should automatically create fixtures container and append it to DOM", function() {
          jasmine.getFixtures().appendSet(html);
          return expect(fixturesContainer().size()).toEqual(1);
        });
      });
      return describe("when fixture container exists", function() {
        beforeEach(function() {
          return jasmine.getFixtures().appendSet(html);
        });
        return it("should add new content", function() {
          jasmine.getFixtures().appendSet(html);
          return expect(fixturesContainer().html()).toEqual(jasmine.JQuery.browserTagCaseIndependentHtml(html) + jasmine.JQuery.browserTagCaseIndependentHtml(html));
        });
      });
    });
    describe("sandbox", function() {
      describe("with no attributes parameter specified", function() {
        return it("should create DIV with id #sandbox", function() {
          return expect(jasmine.getFixtures().sandbox().html()).toEqual($("<div id=\"sandbox\" />").html());
        });
      });
      describe("with attributes parameter specified", function() {
        it("should create DIV with attributes", function() {
          var attributes, element;

          attributes = {
            attr1: "attr1 value",
            attr2: "attr2 value"
          };
          element = $(jasmine.getFixtures().sandbox(attributes));
          expect(element.attr("attr1")).toEqual(attributes.attr1);
          return expect(element.attr("attr2")).toEqual(attributes.attr2);
        });
        return it("should be able to override id by setting it as attribute", function() {
          var element, idOverride;

          idOverride = "overridden";
          element = $(jasmine.getFixtures().sandbox({
            id: idOverride
          }));
          return expect(element.attr("id")).toEqual(idOverride);
        });
      });
      return it("should have shortcut global method sandbox", function() {
        var attributes, element;

        attributes = {
          id: "overridden"
        };
        element = $(sandbox(attributes));
        return expect(element.attr("id")).toEqual(attributes.id);
      });
    });
    describe("cleanUp", function() {
      return it("should remove fixtures container from DOM", function() {
        appendFixturesContainerToDom();
        jasmine.getFixtures().cleanUp();
        return expect(fixturesContainer().size()).toEqual(0);
      });
    });
    return describe("automatic DOM clean-up between tests", function() {
      it("FIRST TEST: should pollute the DOM", function() {
        return appendFixturesContainerToDom();
      });
      return it("SECOND TEST: should see the DOM in a blank state", function() {
        return expect(fixturesContainer().size()).toEqual(0);
      });
    });
  });

  describe("jasmine.Fixtures using real AJAX call", function() {
    beforeEach(function() {
      var defaultFixturesPath;

      defaultFixturesPath = jasmine.getFixtures().fixturesPath;
      return jasmine.getFixtures().fixturesPath = "spec/fixtures";
    });
    afterEach(function() {
      return jasmine.getFixtures().fixturesPath = defaultFixturesPath;
    });
    return describe("when fixture file exists", function() {
      var fixtureUrl;

      fixtureUrl = "real_non_mocked_fixture.html";
      return it("should load content of fixture file", function() {
        var fixtureContent;

        fixtureContent = jasmine.getFixtures().read(fixtureUrl);
        return expect(fixtureContent).toEqual("<div id=\"real_non_mocked_fixture\"></div>");
      });
    });
  });

  describe("jQuery matchers", function() {
    describe("when jQuery matcher hides original Jasmine matcher", function() {
      describe("and tested item is jQuery object", function() {
        return it("should invoke jQuery version of matcher", function() {
          return expect($("<div />")).toBe("div");
        });
      });
      describe("and tested item is not jQuery object", function() {
        return it("should invoke original version of matcher", function() {
          return expect(true).toBe(true);
        });
      });
      return describe("and tested item is a dom object", function() {
        return it("should invoke jquery version of matcher", function() {
          return expect($("<div />").get(0)).toBe("div");
        });
      });
    });
    describe("when jQuery matcher does not hide any original Jasmine matcher", function() {
      return describe("and tested item in not jQuery object", function() {
        return it("should pass negated", function() {
          return expect({}).not.toHaveClass("some-class");
        });
      });
    });
    describe("when invoked multiple times on the same fixture", function() {
      return it("should not reset fixture after first call", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).toExist();
        return expect($("#sandbox")).toExist();
      });
    });
    describe("toHaveClass", function() {
      var className;

      className = "some-class";
      it("should pass when class found", function() {
        setFixtures(sandbox({
          "class": className
        }));
        expect($("#sandbox")).toHaveClass(className);
        return expect($("#sandbox").get(0)).toHaveClass(className);
      });
      it("should pass negated when class not found", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).not.toHaveClass(className);
        return expect($("#sandbox").get(0)).not.toHaveClass(className);
      });
      return it("should not crash when documentElement provided", function() {
        var doc;

        doc = $(document.documentElement).addClass(className);
        expect(doc).toHaveClass(className);
        doc.removeClass(className);
        return expect(doc).not.toHaveClass(className);
      });
    });
    describe("toHaveAttr", function() {
      var attributeName, attributeValue, wrongAttributeName, wrongAttributeValue;

      attributeName = "attr1";
      attributeValue = "attr1 value";
      wrongAttributeName = "wrongName";
      wrongAttributeValue = "wrong value";
      beforeEach(function() {
        var attributes;

        attributes = {};
        attributes[attributeName] = attributeValue;
        return setFixtures(sandbox(attributes));
      });
      describe("when only attribute name is provided", function() {
        it("should pass if element has matching attribute", function() {
          expect($("#sandbox")).toHaveAttr(attributeName);
          return expect($("#sandbox").get(0)).toHaveAttr(attributeName);
        });
        return it("should pass negated if element has no matching attribute", function() {
          expect($("#sandbox")).not.toHaveAttr(wrongAttributeName);
          return expect($("#sandbox").get(0)).not.toHaveAttr(wrongAttributeName);
        });
      });
      return describe("when both attribute name and value are provided", function() {
        it("should pass if element has matching attribute with matching value", function() {
          expect($("#sandbox")).toHaveAttr(attributeName, attributeValue);
          return expect($("#sandbox").get(0)).toHaveAttr(attributeName, attributeValue);
        });
        it("should pass negated if element has matching attribute but with wrong value", function() {
          expect($("#sandbox")).not.toHaveAttr(attributeName, wrongAttributeValue);
          return expect($("#sandbox").get(0)).not.toHaveAttr(attributeName, wrongAttributeValue);
        });
        return it("should pass negated if element has no matching attribute", function() {
          expect($("#sandbox")).not.toHaveAttr(wrongAttributeName, attributeValue);
          return expect($("#sandbox").get(0)).not.toHaveAttr(wrongAttributeName, attributeValue);
        });
      });
    });
    describe("toHaveProp", function() {
      var propertyName, propertyValue, wrongPropertyName, wrongPropertyValue;

      propertyName = "prop1";
      propertyValue = "prop1 value";
      wrongPropertyName = "wrongName";
      wrongPropertyValue = "wrong value";
      beforeEach(function() {
        var element;

        setFixtures(sandbox());
        element = $("#sandbox")[0];
        return element[propertyName] = propertyValue;
      });
      describe("when only property name is provided", function() {
        it("should pass if element has matching property", function() {
          return expect($("#sandbox")).toHaveProp(propertyName);
        });
        return it("should pass negated if element has no matching property", function() {
          return expect($("#sandbox")).not.toHaveProp(wrongPropertyName);
        });
      });
      return describe("when both property name and value are provided", function() {
        it("should pass if element has matching property with matching value", function() {
          return expect($("#sandbox")).toHaveProp(propertyName, propertyValue);
        });
        it("should pass negated if element has matching property but with wrong value", function() {
          return expect($("#sandbox")).not.toHaveProp(propertyName, wrongPropertyValue);
        });
        return it("should pass negated if element has no matching property", function() {
          return expect($("#sandbox")).not.toHaveProp(wrongPropertyName, propertyValue);
        });
      });
    });
    describe("toHaveCss", function() {
      beforeEach(function() {
        return setFixtures(sandbox());
      });
      it("should pass if the element has matching css", function() {
        $("#sandbox").css("display", "none");
        $("#sandbox").css("margin-left", "10px");
        return expect($("#sandbox")).toHaveCss({
          display: "none",
          "margin-left": "10px"
        });
      });
      it("should be able to check a subset of element's css", function() {
        $("#sandbox").css("display", "none");
        $("#sandbox").css("margin-left", "10px");
        return expect($("#sandbox")).toHaveCss({
          "margin-left": "10px"
        });
      });
      return it("should fail if the element doesn't have matching css", function() {
        $("#sandbox").css("display", "none");
        $("#sandbox").css("margin-left", "20px");
        return expect($("#sandbox")).not.toHaveCss({
          display: "none",
          "margin-left": "10px"
        });
      });
    });
    describe("toHaveId", function() {
      beforeEach(function() {
        return setFixtures(sandbox());
      });
      it("should pass if id attribute matches expectation", function() {
        expect($("#sandbox")).toHaveId("sandbox");
        return expect($("#sandbox").get(0)).toHaveId("sandbox");
      });
      it("should pass negated if id attribute does not match expectation", function() {
        expect($("#sandbox")).not.toHaveId("wrongId");
        return expect($("#sandbox").get(0)).not.toHaveId("wrongId");
      });
      return it("should pass negated if id attribute is not present", function() {
        expect($("<div />")).not.toHaveId("sandbox");
        return expect($("<div />").get(0)).not.toHaveId("sandbox");
      });
    });
    describe("toHaveHtml", function() {
      var html, wrongHtml;

      html = "<div>some text</div>";
      wrongHtml = "<span>some text</span>";
      beforeEach(function() {
        var element;

        return element = $("<div/>").append(html);
      });
      it("should pass when html matches", function() {
        expect(element).toHaveHtml(html);
        return expect(element.get(0)).toHaveHtml(html);
      });
      return it("should pass negated when html does not match", function() {
        expect(element).not.toHaveHtml(wrongHtml);
        return expect(element.get(0)).not.toHaveHtml(wrongHtml);
      });
    });
    describe("toContainHtml", function() {
      beforeEach(function() {
        return setFixtures(sandbox());
      });
      it("should pass when the element contains given html", function() {
        $("#sandbox").html("<div><ul></ul><h1>foo</h1></div>");
        return expect($("#sandbox")).toContainHtml("<ul></ul>");
      });
      return it("should fail when the element doesn't contain given html", function() {
        $("#sandbox").html("<div><h1>foo</h1></div>");
        return expect($("#sandbox")).not.toContainHtml("<ul></ul>");
      });
    });
    describe("toHaveText", function() {
      var text, wrongText;

      text = "some text";
      wrongText = "some other text";
      beforeEach(function() {
        var element;

        return element = $("<div/>").append(text);
      });
      it("should pass when text matches", function() {
        expect(element).toHaveText(text);
        return expect(element.get(0)).toHaveText(text);
      });
      it("should ignore surrounding whitespace", function() {
        var element;

        element = $("<div>\n" + text + "\n</div>");
        expect(element).toHaveText(text);
        return expect(element.get(0)).toHaveText(text);
      });
      it("should pass negated when text does not match", function() {
        expect(element).not.toHaveText(wrongText);
        return expect(element.get(0)).not.toHaveText(wrongText);
      });
      it("should pass when text matches a regex", function() {
        expect(element).toHaveText(/some/);
        return expect(element.get(0)).toHaveText(/some/);
      });
      return it("should pass negated when text does not match a regex", function() {
        expect(element).not.toHaveText(/other/);
        return expect(element.get(0)).not.toHaveText(/other/);
      });
    });
    describe("toContainText", function() {
      var text, textPart, wrongText;

      text = "some pretty long bits of text";
      textPart = "pret";
      wrongText = "some other text";
      beforeEach(function() {
        var element;

        return element = $("<div/>").append(text);
      });
      it("should pass when text contains text part", function() {
        expect(element).toContainText(textPart);
        return expect(element.get(0)).toContainText(textPart);
      });
      it("should pass negated when text does not match", function() {
        expect(element).not.toContainText(wrongText);
        return expect(element.get(0)).not.toContainText(wrongText);
      });
      it("should pass when text matches a regex", function() {
        expect(element).toContainText(/some/);
        return expect(element.get(0)).toContainText(/some/);
      });
      return it("should pass negated when text does not match a regex", function() {
        expect(element).not.toContainText(/other/);
        return expect(element.get(0)).not.toContainText(/other/);
      });
    });
    describe("toHaveValue", function() {
      var differentValue, value;

      value = "some value";
      differentValue = "different value";
      beforeEach(function() {
        return setFixtures($("<input id=\"sandbox\" type=\"text\" />").val(value));
      });
      it("should pass if value matches expectation", function() {
        expect($("#sandbox")).toHaveValue(value);
        return expect($("#sandbox").get(0)).toHaveValue(value);
      });
      it("should pass negated if value does not match expectation", function() {
        expect($("#sandbox")).not.toHaveValue(differentValue);
        return expect($("#sandbox").get(0)).not.toHaveValue(differentValue);
      });
      it("should pass negated if value attribute is not present", function() {
        expect(sandbox()).not.toHaveValue(value);
        return expect(sandbox().get(0)).not.toHaveValue(value);
      });
      return it("should not coerce types", function() {
        setFixtures($("<input id=\"sandbox\" type=\"text\" />").val(""));
        return expect($("#sandbox")).not.toHaveValue(0);
      });
    });
    describe("toHaveData", function() {
      var key, value, wrongKey, wrongValue;

      key = "some key";
      value = "some value";
      wrongKey = "wrong key";
      wrongValue = "wrong value";
      beforeEach(function() {
        return setFixtures(sandbox().data(key, value));
      });
      describe("when only key is provided", function() {
        it("should pass if element has matching data key", function() {
          expect($("#sandbox")).toHaveData(key);
          return expect($("#sandbox").get(0)).toHaveData(key);
        });
        return it("should pass negated if element has no matching data key", function() {
          expect($("#sandbox")).not.toHaveData(wrongKey);
          return expect($("#sandbox").get(0)).not.toHaveData(wrongKey);
        });
      });
      return describe("when both key and value are provided", function() {
        it("should pass if element has matching key with matching value", function() {
          expect($("#sandbox")).toHaveData(key, value);
          return expect($("#sandbox").get(0)).toHaveData(key, value);
        });
        it("should pass negated if element has matching key but with wrong value", function() {
          expect($("#sandbox")).not.toHaveData(key, wrongValue);
          return expect($("#sandbox").get(0)).not.toHaveData(key, wrongValue);
        });
        return it("should pass negated if element has no matching key", function() {
          expect($("#sandbox")).not.toHaveData(wrongKey, value);
          return expect($("#sandbox").get(0)).not.toHaveData(wrongKey, value);
        });
      });
    });
    describe("toBeVisible", function() {
      it("should pass on visible element", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).toBeVisible();
        return expect($("#sandbox").get(0)).toBeVisible();
      });
      return it("should pass negated on hidden element", function() {
        setFixtures(sandbox().hide());
        expect($("#sandbox")).not.toBeVisible();
        return expect($("#sandbox").get(0)).not.toBeVisible();
      });
    });
    describe("toBeHidden", function() {
      it("should pass on hidden element", function() {
        setFixtures(sandbox().hide());
        expect($("#sandbox")).toBeHidden();
        return expect($("#sandbox").get(0)).toBeHidden();
      });
      return it("should pass negated on visible element", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).not.toBeHidden();
        return expect($("#sandbox").get(0)).not.toBeHidden();
      });
    });
    describe("toBeSelected", function() {
      beforeEach(function() {
        return setFixtures("        <select>\n          <option id=\"not-selected\"></option>\n          <option id=\"selected\" selected=\"selected\"></option>\n        </select>");
      });
      it("should pass on selected element", function() {
        expect($("#selected")).toBeSelected();
        return expect($("#selected").get(0)).toBeSelected();
      });
      return it("should pass negated on not selected element", function() {
        expect($("#not-selected")).not.toBeSelected();
        return expect($("#not-selected").get(0)).not.toBeSelected();
      });
    });
    describe("toBeChecked", function() {
      beforeEach(function() {
        return setFixtures("        <input type=\"checkbox\" id=\"checked\" checked=\"checked\" />\n        <input type=\"checkbox\" id=\"not-checked\" />");
      });
      it("should pass on checked element", function() {
        expect($("#checked")).toBeChecked();
        return expect($("#checked").get(0)).toBeChecked();
      });
      return it("should pass negated on not checked element", function() {
        expect($("#not-checked")).not.toBeChecked();
        return expect($("#not-checked").get(0)).not.toBeChecked();
      });
    });
    describe("toBeEmpty", function() {
      it("should pass on empty element", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).toBeEmpty();
        return expect($("#sandbox").get(0)).toBeEmpty();
      });
      it("should pass negated on element with a tag inside", function() {
        setFixtures(sandbox().html($("<span />")));
        expect($("#sandbox")).not.toBeEmpty();
        return expect($("#sandbox").get(0)).not.toBeEmpty();
      });
      return it("should pass negated on element with text inside", function() {
        setFixtures(sandbox().text("some text"));
        expect($("#sandbox")).not.toBeEmpty();
        return expect($("#sandbox").get(0)).not.toBeEmpty();
      });
    });
    describe("toExist", function() {
      it("should pass on visible element", function() {
        setFixtures(sandbox());
        expect($("#sandbox")).toExist();
        return expect($("#sandbox").get(0)).toExist();
      });
      it("should pass on hidden element", function() {
        setFixtures(sandbox().hide());
        expect($("#sandbox")).toExist();
        return expect($("#sandbox").get(0)).toExist();
      });
      it("should pass negated if element is not present in DOM", function() {
        expect($("#non-existent-element")).not.toExist();
        return expect($("#non-existent-element").get(0)).not.toExist();
      });
      return it("should pass on negated removed element", function() {
        var el;

        setFixtures(sandbox());
        el = $("#sandbox");
        el.remove();
        return expect(el).not.toExist();
      });
    });
    describe("toHaveLength", function() {
      it("should pass on an object with more than zero items", function() {
        var $three;

        $three = $("<div>").add("<span>").add("<pre>");
        expect($three.length).toBe(3);
        return expect($three).toHaveLength(3);
      });
      it("should pass negated on an object with more than zero items", function() {
        var $three;

        $three = $("<div>").add("<span>").add("<pre>");
        expect($three.length).toBe(3);
        return expect($three).not.toHaveLength(2);
      });
      it("should pass on an object with zero items", function() {
        var $zero;

        $zero = $();
        expect($zero.length).toBe(0);
        return expect($zero).toHaveLength(0);
      });
      return it("should pass negated on an object with zero items", function() {
        var $zero;

        $zero = $();
        expect($zero.length).not.toBe(1);
        return expect($zero).not.toHaveLength(1);
      });
    });
    describe("toBe", function() {
      beforeEach(function() {
        return setFixtures(sandbox());
      });
      it("should pass if object matches selector", function() {
        expect($("#sandbox")).toBe("#sandbox");
        return expect($("#sandbox").get(0)).toBe("#sandbox");
      });
      return it("should pass negated if object does not match selector", function() {
        expect($("#sandbox")).not.toBe("#wrong-id");
        return expect($("#sandbox").get(0)).not.toBe("#wrong-id");
      });
    });
    describe("toContain", function() {
      beforeEach(function() {
        return setFixtures(sandbox().html("<span />"));
      });
      it("should pass if object contains selector", function() {
        expect($("#sandbox")).toContain("span");
        return expect($("#sandbox").get(0)).toContain("span");
      });
      return it("should pass negated if object does not contain selector", function() {
        expect($("#sandbox")).not.toContain("div");
        return expect($("#sandbox").get(0)).not.toContain("div");
      });
    });
    describe("toBeDisabled", function() {
      beforeEach(function() {
        return setFixtures("        <input type=\"text\" disabled=\"disabled\" id=\"disabled\"/>\n        <input type=\"text\" id=\"enabled\"/>");
      });
      it("should pass on disabled element", function() {
        expect($("#disabled")).toBeDisabled();
        return expect($("#disabled").get(0)).toBeDisabled();
      });
      return it("should pass negated on not selected element", function() {
        expect($("#enabled")).not.toBeDisabled();
        return expect($("#enabled").get(0)).not.toBeDisabled();
      });
    });
    describe("toBeFocused", function() {
      beforeEach(function() {
        return setFixtures("<input type=\"text\" id=\"focused\"/>");
      });
      it("should pass on focused element", function() {
        var el;

        el = $("#focused").focus();
        return expect(el).toBeFocused();
      });
      return it("should pass negated on not focused element", function() {
        var el;

        el = $("#focused");
        return expect(el).not.toBeFocused();
      });
    });
    describe("toHaveBeenTriggeredOn", function() {
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyOnEvent($("#clickme"), "click");
        spyOnEvent(document, "click");
        return spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was triggered on the object", function() {
        $("#clickme").click();
        expect("click").toHaveBeenTriggeredOn($("#clickme"));
        return expect("click").toHaveBeenTriggeredOn("#clickme");
      });
      it("should pass if the event was triggered on document", function() {
        $(document).click();
        expect("click").toHaveBeenTriggeredOn($(document));
        return expect("click").toHaveBeenTriggeredOn(document);
      });
      it("should pass if the event was triggered on a descendant of document", function() {
        $("#clickme").click();
        expect("click").toHaveBeenTriggeredOn($(document));
        return expect("click").toHaveBeenTriggeredOn(document);
      });
      it("should pass negated if the event was never triggered", function() {
        expect("click").not.toHaveBeenTriggeredOn($("#clickme"));
        return expect("click").not.toHaveBeenTriggeredOn("#clickme");
      });
      return it("should pass negated if the event was triggered on another non-descendant object", function() {
        $("#otherlink").click();
        expect("click").not.toHaveBeenTriggeredOn($("#clickme"));
        return expect("click").not.toHaveBeenTriggeredOn("#clickme");
      });
    });
    describe("toHaveBeenTriggeredOnAndWith", function() {
      beforeEach(function() {
        return spyOnEvent(document, "event");
      });
      describe("when extra parameter is an object", function() {
        it("should pass if the event was triggered on the object with expected arguments", function() {
          $(document).trigger("event", {
            key1: "value1",
            key2: "value2"
          });
          return expect("event").toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1",
            key2: "value2"
          });
        });
        it("should pass negated if the event was never triggered", function() {
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1",
            key2: "value2"
          });
        });
        it("should pass negated if the event was triggered on another non-descendant object", function() {
          $(window).trigger("event", {
            key1: "value1",
            key2: "value2"
          });
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1",
            key2: "value2"
          });
        });
        return it("should pass negated if the event was triggered but the arguments do not match with the expected arguments", function() {
          $(document).trigger("event", {
            key1: "value1"
          });
          expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1",
            key2: "value2"
          });
          $(document).trigger("event", {
            key1: "value1",
            key2: "value2"
          });
          expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1"
          });
          $(document).trigger("event", {
            key1: "different value"
          });
          expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1"
          });
          $(document).trigger("event", {
            different_key: "value1"
          });
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, {
            key1: "value1"
          });
        });
      });
      return describe("when extra parameter is an array", function() {
        it("should pass if the event was triggered on the object with expected arguments", function() {
          $(document).trigger("event", [1, 2]);
          return expect("event").toHaveBeenTriggeredOnAndWith(document, [1, 2]);
        });
        it("should pass negated if the event was never triggered", function() {
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, [1, 2]);
        });
        it("should pass negated if the event was triggered on another non-descendant object", function() {
          $(window).trigger("event", [1, 2]);
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, [1, 2]);
        });
        return it("should pass negated if the event was triggered but the arguments do not match with the expected arguments", function() {
          $(document).trigger("event", [1]);
          expect("event").not.toHaveBeenTriggeredOnAndWith(document, [1, 2]);
          $(document).trigger("event", [1, 2]);
          expect("event").not.toHaveBeenTriggeredOnAndWith(document, [1]);
          $(document).trigger("event", [1, 3]);
          return expect("event").not.toHaveBeenTriggeredOnAndWith(document, [1, 2]);
        });
      });
    });
    describe("toHaveBeenTriggered", function() {
      var spyEvents;

      spyEvents = {};
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyEvents["#clickme"] = spyOnEvent($("#clickme"), "click");
        return spyEvents["#otherlink"] = spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was triggered on the object", function() {
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).toHaveBeenTriggered();
      });
      it("should pass negated if the event was never triggered", function() {
        return expect(spyEvents["#clickme"]).not.toHaveBeenTriggered();
      });
      it("should pass negated if the event was triggered on another non-descendant object", function() {
        $("#otherlink").click();
        return expect(spyEvents["#clickme"]).not.toHaveBeenTriggered();
      });
      return it("should pass negated if the spy event was reset", function() {
        $("#clickme").click();
        expect("click").toHaveBeenTriggeredOn($("#clickme"));
        expect("click").toHaveBeenTriggeredOn("#clickme");
        expect(spyEvents["#clickme"]).toHaveBeenTriggered();
        spyEvents["#clickme"].reset();
        expect("click").not.toHaveBeenTriggeredOn($("#clickme"));
        expect("click").not.toHaveBeenTriggeredOn("#clickme");
        return expect(spyEvents["#clickme"]).not.toHaveBeenTriggered();
      });
    });
    describe("toHaveBeenPreventedOn", function() {
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyOnEvent($("#clickme"), "click");
        return spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was prevented on the object", function() {
        $("#clickme").bind("click", function(event) {
          return event.preventDefault();
        });
        $("#clickme").click();
        expect("click").toHaveBeenPreventedOn($("#clickme"));
        return expect("click").toHaveBeenPreventedOn("#clickme");
      });
      it("should pass negated if the event was never prevented", function() {
        $("#clickme").click();
        expect("click").not.toHaveBeenPreventedOn($("#clickme"));
        return expect("click").not.toHaveBeenPreventedOn("#clickme");
      });
      return it("should pass negated if the event was prevented on another non-descendant object", function() {
        $("#otherlink").bind("click", function(event) {
          return event.preventDefault();
        });
        $("#clickme").click();
        return expect("click").not.toHaveBeenPreventedOn($("#clickme"));
      });
    });
    describe("toHaveBeenPrevented", function() {
      var spyEvents;

      spyEvents = {};
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyEvents["#clickme"] = spyOnEvent($("#clickme"), "click");
        return spyEvents["#otherlink"] = spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was prevented on the object", function() {
        $("#clickme").bind("click", function(event) {
          return event.preventDefault();
        });
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).toHaveBeenPrevented();
      });
      it("should pass negated if the event was never prevented", function() {
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).not.toHaveBeenPrevented();
      });
      it("should pass negated if the event was prevented on another non-descendant object", function() {
        $("#otherlink").bind("click", function(event) {
          return event.preventDefault();
        });
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).not.toHaveBeenPrevented();
      });
      return it("should pass negated if nothing was triggered", function() {
        return expect(spyEvents["#clickme"]).not.toHaveBeenPrevented();
      });
    });
    describe("toHaveBeenStoppedOn", function() {
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyOnEvent($("#clickme"), "click");
        return spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was stopped on the object", function() {
        $("#clickme").bind("click", function(event) {
          return event.stopPropagation();
        });
        $("#clickme").click();
        expect("click").toHaveBeenStoppedOn($("#clickme"));
        return expect("click").toHaveBeenStoppedOn("#clickme");
      });
      it("should pass negated if the event was never stopped", function() {
        $("#clickme").click();
        expect("click").not.toHaveBeenStoppedOn($("#clickme"));
        return expect("click").not.toHaveBeenStoppedOn("#clickme");
      });
      return it("should pass negated if the event was stopped on another non-descendant object", function() {
        $("#otherlink").bind("click", function(event) {
          return event.stopPropagation();
        });
        $("#clickme").click();
        return expect("click").not.toHaveBeenStoppedOn($("#clickme"));
      });
    });
    describe("toHaveBeenStopped", function() {
      var spyEvents;

      spyEvents = {};
      beforeEach(function() {
        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        spyEvents["#clickme"] = spyOnEvent($("#clickme"), "click");
        return spyEvents["#otherlink"] = spyOnEvent($("#otherlink"), "click");
      });
      it("should pass if the event was stopped on the object", function() {
        $("#clickme").bind("click", function(event) {
          return event.stopPropagation();
        });
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).toHaveBeenStopped();
      });
      it("should pass negated if the event was never stopped", function() {
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).not.toHaveBeenStopped();
      });
      it("should pass negated if the event was stopped on another non-descendant object", function() {
        $("#otherlink").bind("click", function(event) {
          return event.stopPropagation();
        });
        $("#clickme").click();
        return expect(spyEvents["#clickme"]).not.toHaveBeenStopped();
      });
      return it("should pass negated if nothing was triggered", function() {
        return expect(spyEvents["#clickme"]).not.toHaveBeenStopped();
      });
    });
    describe("toHandle", function() {
      beforeEach(function() {
        var handler;

        setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
        return handler = function() {};
      });
      it("should handle events on the window object", function() {
        $(window).bind("resize", handler);
        return expect($(window)).toHandle("resize");
      });
      it("should pass if the event is bound", function() {
        $("#clickme").bind("click", handler);
        expect($("#clickme")).toHandle("click");
        return expect($("#clickme").get(0)).toHandle("click");
      });
      it("should pass if the event is not bound", function() {
        expect($("#clickme")).not.toHandle("click");
        return expect($("#clickme").get(0)).not.toHandle("click");
      });
      it("should pass if the namespaced event is bound", function() {
        $("#clickme").bind("click", handler);
        $("#clickme").bind("click.NameSpace", handler);
        return expect($("#clickme")).toHandle("click.NameSpace");
      });
      it("should not fail when events is empty", function() {
        $("#clickme").change(function() {});
        return expect($("#clickme")).not.toHandle("click");
      });
      it("should recognize an event with multiple namespaces", function() {
        $("#clickme").bind("click.NSone.NStwo.NSthree", handler);
        expect($("#clickme")).toHandle("click.NSone");
        expect($("#clickme")).toHandle("click.NStwo");
        expect($("#clickme")).toHandle("click.NSthree");
        expect($("#clickme")).toHandle("click.NSthree.NStwo");
        expect($("#clickme")).toHandle("click.NStwo.NSone");
        return expect($("#clickme")).toHandle("click");
      });
      it("should pass if a namespaced event is not bound", function() {
        $("#clickme").bind("click", handler);
        $("#clickme").bind("click.OtherNameSpace", handler);
        return expect($("#clickme")).not.toHandle("click.NameSpace");
      });
      return it("should handle event on any object", function() {
        var object;

        object = new function() {};
        $(object).bind("click", function() {});
        return expect($(object)).toHandle("click");
      });
    });
    return describe("toHandleWith", function() {
      beforeEach(function() {
        return setFixtures(sandbox().html("<a id=\"clickme\">Click Me</a> <a id=\"otherlink\">Other Link</a>"));
      });
      it("should pass if the event is bound with the given handler", function() {
        var handler;

        handler = function() {};
        $("#clickme").bind("click", handler);
        expect($("#clickme")).toHandleWith("click", handler);
        return expect($("#clickme").get(0)).toHandleWith("click", handler);
      });
      it("should pass if the event is not bound with the given handler", function() {
        var aDifferentHandler, handler;

        handler = function() {};
        $("#clickme").bind("click", handler);
        aDifferentHandler = function() {};
        expect($("#clickme")).not.toHandleWith("click", aDifferentHandler);
        return expect($("#clickme").get(0)).not.toHandleWith("click", aDifferentHandler);
      });
      it("should pass if the event is not bound at all", function() {
        expect($("#clickme")).not.toHandle("click");
        return expect($("#clickme").get(0)).not.toHandle("click");
      });
      it("should pass if the event on window is bound with the given handler", function() {
        var handler;

        handler = function() {};
        $(window).bind("resize", handler);
        return expect($(window)).toHandleWith("resize", handler);
      });
      return it("should pass if the event on any object is bound with the given handler", function() {
        var handler, object;

        object = new function() {};
        handler = function() {};
        $(object).bind("click", handler);
        return expect($(object)).toHandleWith("click", handler);
      });
    });
  });

  describe("jasmine.StyleFixtures", function() {
    var ajaxData, anotherFixtureUrl, fixtureUrl, fixturesContainer;

    ajaxData = "some ajax data";
    fixtureUrl = "some_url";
    anotherFixtureUrl = "another_url";
    fixturesContainer = function() {
      return $("head style").last();
    };
    beforeEach(function() {
      jasmine.getStyleFixtures().clearCache();
      return spyOn(jasmine.StyleFixtures.prototype, "loadFixtureIntoCache_").andCallFake(function(relativeUrl) {
        return this.fixturesCache_[relativeUrl] = ajaxData;
      });
    });
    describe("default initial config values", function() {
      return it("should set 'spec/javascripts/fixtures' as the default style fixtures path", function() {
        return expect(jasmine.getStyleFixtures().fixturesPath).toEqual("spec/javascripts/fixtures");
      });
    });
    describe("load", function() {
      it("should insert CSS fixture within style tag into HEAD", function() {
        var stylesNumOld;

        stylesNumOld = $("head style").length;
        jasmine.getStyleFixtures().load(fixtureUrl);
        expect($("head style").length - stylesNumOld).toEqual(1);
        return expect(fixturesContainer().html()).toEqual(ajaxData);
      });
      it("should insert duplicated CSS fixture into one style tag when the same url is provided twice in a single call", function() {
        jasmine.getStyleFixtures().load(fixtureUrl, fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should insert merged CSS of two fixtures into one style tag when two different urls are provided in a single call", function() {
        jasmine.getStyleFixtures().load(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      return it("should have shortcut global method loadStyleFixtures", function() {
        loadStyleFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
    });
    describe("appendLoad", function() {
      beforeEach(function() {
        return ajaxData = "some ajax data";
      });
      it("should insert CSS fixture within style tag into HEAD", function() {
        var stylesNumOld;

        stylesNumOld = $("head style").length;
        jasmine.getStyleFixtures().appendLoad(fixtureUrl);
        expect($("head style").length - stylesNumOld).toEqual(1);
        return expect(fixturesContainer().html()).toEqual(ajaxData);
      });
      it("should insert duplicated CSS fixture into one style tag when the same url is provided twice in a single call", function() {
        jasmine.getStyleFixtures().appendLoad(fixtureUrl, fixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should insert merged CSS of two fixtures into one style tag when two different urls are provided in a single call", function() {
        jasmine.getStyleFixtures().appendLoad(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      it("should have shortcut global method appendLoadStyleFixtures", function() {
        appendLoadStyleFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
      });
      return describe("with a prexisting fixture", function() {
        beforeEach(function() {
          return jasmine.getStyleFixtures().appendLoad(fixtureUrl);
        });
        it("should add new content within new style tag in HEAD", function() {
          jasmine.getStyleFixtures().appendLoad(anotherFixtureUrl);
          return expect(fixturesContainer().html()).toEqual(ajaxData);
        });
        return it("should not delete prexisting fixtures", function() {
          jasmine.getStyleFixtures().appendLoad(anotherFixtureUrl);
          return expect(fixturesContainer().prev().html()).toEqual(ajaxData);
        });
      });
    });
    describe("preload", function() {
      describe("load after preload", function() {
        it("should go from cache", function() {
          jasmine.getStyleFixtures().preload(fixtureUrl, anotherFixtureUrl);
          jasmine.getStyleFixtures().load(fixtureUrl, anotherFixtureUrl);
          return expect(jasmine.StyleFixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(2);
        });
        return it("should return correct CSSs", function() {
          jasmine.getStyleFixtures().preload(fixtureUrl, anotherFixtureUrl);
          jasmine.getStyleFixtures().load(fixtureUrl, anotherFixtureUrl);
          return expect(fixturesContainer().html()).toEqual(ajaxData + ajaxData);
        });
      });
      it("should not preload the same fixture twice", function() {
        jasmine.getStyleFixtures().preload(fixtureUrl, fixtureUrl);
        return expect(jasmine.StyleFixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(1);
      });
      return it("should have shortcut global method preloadStyleFixtures", function() {
        preloadStyleFixtures(fixtureUrl, anotherFixtureUrl);
        return expect(jasmine.StyleFixtures.prototype.loadFixtureIntoCache_.callCount).toEqual(2);
      });
    });
    describe("set", function() {
      var css;

      css = "body { color: red }";
      it("should insert CSS within style tag into HEAD", function() {
        var stylesNumOld;

        stylesNumOld = $("head style").length;
        jasmine.getStyleFixtures().set(css);
        expect($("head style").length - stylesNumOld).toEqual(1);
        return expect(fixturesContainer().html()).toEqual(css);
      });
      return it("should have shortcut global method setStyleFixtures", function() {
        setStyleFixtures(css);
        return expect(fixturesContainer().html()).toEqual(css);
      });
    });
    describe("appendSet", function() {
      var css;

      css = "body { color: red }";
      it("should insert CSS within style tag into HEAD", function() {
        var stylesNumOld;

        stylesNumOld = $("head style").length;
        jasmine.getStyleFixtures().appendSet(css);
        expect($("head style").length - stylesNumOld).toEqual(1);
        return expect(fixturesContainer().html()).toEqual(css);
      });
      it("should have shortcut global method appendSetStyleFixtures", function() {
        appendSetStyleFixtures(css);
        return expect(fixturesContainer().html()).toEqual(css);
      });
      return describe("when fixture container exists", function() {
        beforeEach(function() {
          return jasmine.getStyleFixtures().appendSet(css);
        });
        it("should add new content within new style tag in HEAD", function() {
          jasmine.getStyleFixtures().appendSet(css);
          return expect(fixturesContainer().html()).toEqual(css);
        });
        return it("should not delete prexisting fixtures", function() {
          jasmine.getStyleFixtures().appendSet(css);
          return expect(fixturesContainer().prev().html()).toEqual(css);
        });
      });
    });
    describe("cleanUp", function() {
      return it("should remove CSS fixtures from DOM", function() {
        var stylesNumOld;

        stylesNumOld = $("head style").length;
        jasmine.getStyleFixtures().load(fixtureUrl, anotherFixtureUrl);
        jasmine.getStyleFixtures().cleanUp();
        return expect($("head style").length).toEqual(stylesNumOld);
      });
    });
    return describe("automatic DOM clean-up between tests", function() {
      var stylesNumOld;

      stylesNumOld = $("head style").length;
      it("FIRST TEST: should pollute the DOM", function() {
        jasmine.getStyleFixtures().load(fixtureUrl);
        return expect($("head style").length).toEqual(stylesNumOld + 1);
      });
      return it("SECOND TEST: should see the DOM in a blank state", function() {
        return expect($("head style").length).toEqual(stylesNumOld);
      });
    });
  });

  describe("jasmine.StyleFixtures using real AJAX call", function() {
    beforeEach(function() {
      var defaultFixturesPath;

      defaultFixturesPath = jasmine.getStyleFixtures().fixturesPath;
      return jasmine.getStyleFixtures().fixturesPath = "spec/fixtures";
    });
    afterEach(function() {
      return jasmine.getStyleFixtures().fixturesPath = defaultFixturesPath;
    });
    return describe("when fixture file exists", function() {
      var fixtureUrl;

      fixtureUrl = "real_non_mocked_fixture_style.css";
      return it("should load content of fixture file", function() {
        jasmine.getStyleFixtures().load(fixtureUrl);
        return expect($("head style").last().html()).toEqual("body { background: red; }");
      });
    });
  });

  describe("jasmine.JSONFixtures", function() {
    var ajaxData, anotherFixtureUrl, fixtureUrl, moreAjaxData, _sortedKeys;

    ajaxData = {
      a: 1,
      b: 2,
      arr: [1, 2, "stuff"],
      hsh: {
        blurp: 8,
        blop: "blip"
      }
    };
    moreAjaxData = [1, 2, "stuff"];
    fixtureUrl = "some_json";
    anotherFixtureUrl = "another_json";
    _sortedKeys = function(obj) {
      var arr, k;

      arr = [];
      for (k in obj) {
        arr.push(k);
      }
      return arr.sort();
    };
    beforeEach(function() {
      jasmine.getJSONFixtures().clearCache();
      return spyOn(jasmine.JSONFixtures.prototype, "loadFixtureIntoCache_").andCallFake(function(relativeUrl) {
        var fakeData;

        fakeData = {};
        fakeData[fixtureUrl] = {
          a: 1,
          b: 2,
          arr: [1, 2, "stuff"],
          hsh: {
            blurp: 8,
            blop: "blip"
          }
        };
        fakeData[anotherFixtureUrl] = [1, 2, "stuff"];
        return this.fixturesCache_[relativeUrl] = fakeData[relativeUrl];
      });
    });
    describe("default initial config values", function() {
      return it("should set 'spec/javascripts/fixtures/json' as the default style fixtures path", function() {
        return expect(jasmine.getJSONFixtures().fixturesPath).toEqual("spec/javascripts/fixtures/json");
      });
    });
    describe("load", function() {
      it("should load the JSON data under the key 'fixture_url'", function() {
        var data;

        data = jasmine.getJSONFixtures().load(fixtureUrl);
        expect(_sortedKeys(data)).toEqual([fixtureUrl]);
        return expect(data[fixtureUrl]).toEqual(ajaxData);
      });
      it("should load the JSON data under the key 'fixture_url', even if it's loaded twice in one call", function() {
        var data;

        data = jasmine.getJSONFixtures().load(fixtureUrl, fixtureUrl);
        return expect(_sortedKeys(data)).toEqual([fixtureUrl]);
      });
      it("should load the JSON data under 2 keys given two files in a single call", function() {
        var data;

        data = jasmine.getJSONFixtures().load(anotherFixtureUrl, fixtureUrl);
        expect(_sortedKeys(data)).toEqual([anotherFixtureUrl, fixtureUrl]);
        expect(data[anotherFixtureUrl]).toEqual(moreAjaxData);
        return expect(data[fixtureUrl]).toEqual(ajaxData);
      });
      return it("should have shortcut global method loadJSONFixtures", function() {
        var data;

        data = loadJSONFixtures(fixtureUrl, anotherFixtureUrl);
        expect(_sortedKeys(data)).toEqual([anotherFixtureUrl, fixtureUrl]);
        expect(data[anotherFixtureUrl]).toEqual(moreAjaxData);
        return expect(data[fixtureUrl]).toEqual(ajaxData);
      });
    });
    describe("getJSONFixture", function() {
      return it("fetches the fixture you ask for", function() {
        expect(getJSONFixture(fixtureUrl)).toEqual(ajaxData);
        return expect(getJSONFixture(anotherFixtureUrl)).toEqual(moreAjaxData);
      });
    });
    return describe("reloading data will restore the fixture data", function() {
      beforeEach(function() {
        var data;

        return data = jasmine.getJSONFixtures().load(anotherFixtureUrl)[anotherFixtureUrl];
      });
      it("FIRST TEST: should pollute the fixture data", function() {
        data.push("moredata");
        return expect(data.length).toEqual(4);
      });
      return it("SECOND TEST: should see cleansed JSON fixture data", function() {
        return expect(data.length).toEqual(3);
      });
    });
  });

  describe("jasmine.JSONFixtures using real AJAX call", function() {
    beforeEach(function() {
      var defaultFixturesPath;

      defaultFixturesPath = jasmine.getJSONFixtures().fixturesPath;
      return jasmine.getJSONFixtures().fixturesPath = "spec/fixtures/json";
    });
    afterEach(function() {
      return jasmine.getJSONFixtures().fixturesPath = defaultFixturesPath;
    });
    return describe("when fixture file exists", function() {
      var fixtureUrl;

      fixtureUrl = "jasmine_json_test.json";
      return it("should load content of fixture file", function() {
        var data;

        data = jasmine.getJSONFixtures().load(fixtureUrl);
        return expect(data[fixtureUrl]).toEqual([1, 2, 3]);
      });
    });
  });

}).call(this);
